<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.github.io</id>
    <title>qqz</title>
    <updated>2021-07-01T06:11:05.980Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.github.io"/>
    <link rel="self" href="https://blog.github.io/atom.xml"/>
    <subtitle>&lt;strong&gt;For Alibaba&lt;/strong&gt;</subtitle>
    <logo>https://blog.github.io/images/avatar.png</logo>
    <icon>https://blog.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, qqz</rights>
    <entry>
        <title type="html"><![CDATA[leetcode算法之动态规划]]></title>
        <id>https://blog.github.io/post/leetcode-suan-fa-zhi-dong-tai-gui-hua/</id>
        <link href="https://blog.github.io/post/leetcode-suan-fa-zhi-dong-tai-gui-hua/">
        </link>
        <updated>2021-07-01T02:05:31.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1零钱兑换">1.零钱兑换</h2>
<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p>你可以认为每种硬币的数量是无限的。<br>
<img src="https://blog.github.io/post-images/1625105255152.png" alt="" loading="lazy"></p>
<ol>
<li>递归dfs(效率最低)</li>
</ol>
<pre><code>class Solution{
    int res = Integer.MAX_VALUE;
    public int coinChange(int[] coins,int amount){
        if(coins.length == 0){
            return -1;
        }
        findWay(coins,amount,0);
        //如果没有任何一种硬币组合能够组成总金额，则返回-1
        if(res == Integer.MAX_VALUE){
            return -1;
        }
        return res;
    }
    public void findWay(int[] coins,int amount,int count){
        if(amount &lt; 0){
            return;
        }
        if(amount == 0){
            res = Math.min(res,count);
        }
        for (int i = 0; i &lt; coins.length; i++) {
            findWay(coins,amount-coins[i],count+1);
        }
    }
}
</code></pre>
<ol start="2">
<li>记忆搜索</li>
</ol>
<pre><code>class Solution{
    int[] memo;
    public int coinChange(int[] coins,int amount){
        if(coins.length == 0){
            return -1;
        }
        memo = new int[amount];
        return findWay(coins,amount);
    }
    //memo[n]表示钱币n可以被换取得最少的硬币数，不能换取就为-1
    //findWay函数的目的就是为了找到amount数量的零钱可以兑换的最少硬币数量，返回其值int
    public int findWay(int[] coins,int amount){
        if(amount &lt; 0){
           return -1;
        }
        if(amount == 0){
            return 0;
        }
        //记忆化的处理,若memo[n]赋予了值，就不用继续下面的循环
        //直接的返回memo[n]的最优值
        if(memo[amount-1] != 0){
            return memo[amount-1];
        }
        int min = Integer.MAX_VALUE;
        for (int i = 0; i &lt; coins.length; i++) {
            int res = findWay(coins,amount-coins[i]);
            if(res &gt;= 0 &amp;&amp; res &lt; min){
                min = res + 1; //加1是为了加上得到res结果的那个步骤，兑换的一个硬币
            }
        }
        memo[amount - 1] = (min == Integer.MAX_VALUE ?-1:min);
        return memo[amount-1];
    }
}
</code></pre>
<ol start="3">
<li>动态规划</li>
</ol>
<pre><code>class Solution{
    public int coinChange(int[] coins,int amount){
        int max = amount + 1;
        int[] dp = new int[amount+1];
        Arrays.fill(dp,max);
        dp[0] = 0;
        for (int i = 0; i &lt;= amount; i++) {
            for(int j = 0;j&lt;coins.length;j++){
                if(coins[j]&lt;=i){
                    dp[i] = Math.min(dp[i],dp[i-coins[j]]+1);
                }
            }
        }
        return dp[amount] &gt; amount? -1:dp[amount];
    }
}
</code></pre>
]]></content>
    </entry>
</feed>